## JVM의 역할
- 스택 기반으로 동작하며, JAVA 바이트 코드를 OS에 맞게 해석해주는 역할을 하고, 가비지 컬렉션을 통해 자동적인 메모리 관리를 해 준다.

## 추상클래스와 인터페이스
- 추상 클래스는 클래스 내 추상 메서드가 하나 이상 포함되거나 abstract로 정의된 경우, 인터페이스는 모든 메서드가 추상 메서드로만 이루어진 것을
  말한다.
- 공통점 : new 연산자로 인스턴스 생성이 불가하다.
- 차이점 : 인터페이스는 그 인터페이스를 상속받는 모든 클래스에 대해 특정한 메서드가 반드시 존재해야 하고, 추상 클래스는 상속받는 클래스들의 
공통적인 로직을 추상화시키고, 기능 확장을 위해 사용한다.

## 가비지 컬렉션
- JVM의 메모리 관리 기법 중 하나로, 시스템에서 동적으로 할당된 메모리 영역 중에서 필요없어진 메모리 영역을 회수하여 메모리를 관리해 주는
  기법이다.

## CheckedException 과 UnCheckedExpection의 차이
- CheckedExpection은 실행하기 전에 예측 가능한 예외를 말하고, 반드시 예외 처리를 해야 한다. ex) IOException
- UnCheckedExpection은 실행하고 난 후 알 수 있는 예외, 따로 예외 처리를 하지 않아도 된다. ex) NullPointerExpection
- RuntimeException은 UncheckedException을 상속한 클래스이다.

## JPA 장점
- sql문이 아닌 메서드를 통해 DB를 조작할 수 있어, 개발자는 비즈니스 로직을 구성하는 데에만 집중할 수 있다.
- 자동으로 처리되는 부분이 많아 변경이 일어날 때 손쉽게 바꿀 수 있다.
- 패러다임의 불일치 해결 : Java에서는 상속관계가 존재하는데 데이터베이스에서는 객체의 상속 관계를 지원하지 않아 생기는 문제점을 해결하였다.

## OAuth 2.0
1. 사용자가 클라이언트에 접근하고, 동의를 누르면 구글에 인증을 요청한다.
2. 구글은 인증 코드를 반환하고, 구글에 웹 사이트 등록 시 받은 client ID, client secret, 인증 코드를 구글에 요청한다.
3. 올바른 요청일 경우 구글은 클라이언트에 access token을 발급, 이를 통해 클라이언트는 로그인된 사용자 정보에 접근 가능하다.
- 장점 : 교환을 할 때 secret key가 필요하고, secret key는 백엔드에서만 교환이 이루어지기 때문에 탈취의 가능성이 없다.

## RDBMS vs NOSQL
1. RDBMS는 모든 데이터를 2차원 테이블 형태로 표현한다.
- 장점 : 스키마에 맞춰 데이터를 관리하여, 데이터의 정합성을 보장한다.
- 단점 : 시스템이 커지면 쿼리가 복잡해져, scale-out이 어렵다.

2. NOSQL은 데이터 간의 관계를 정의하지 않고, 스키마가 없으며 컬렉션이라는 형태로 데이터를 관리한다.
- 장점 : 스키마 없이 key-value 형태로 데이터를 관리할 수 있고, scale-out이 용이하다.
- 단점 : 데이터 중복이 발생할 수 있다.

3. RDBMS는 데이터 구조가 명확하고, 중복된 데이터가 없어 관계를 맺고 있는 데이터가 자주 변경되는 시스템에 적합하다.
4. NOSQL은 정확한 데이터 구조를 알 수 없고, 데이터가 변경/확장될 수 있는 경우에 사용. DB를 scale-out해야 하는 시스템에 적합하다.

## 콘보이 현상
- 작업 시간이 긴 프로세스가 먼저 큐에 도착해서, 다른 프로세스의 실행 시간이 전부 늦춰져 효율성을 떨어뜨리는 현상
- FIFO 스케줄링은 콘보이 현상을 발생시킬 수 있다.

## 동기/비동기
- 동기는 순차적, 직렬적으로 태스크를 수행하고, 비동기는 병렬적으로 태스크를 수행한다.

## Critical Section
- 프로세스 간에 공유 자원을 접근하는 데 있어 문제가 발생하지 않도록, 한 번에 하나의 프로세스만 이용하도록 보장해 주어야 하는 영역

## Context Switching
- 멀티 프로세스 환경에서, CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서, 인터럽트 요청에 다음 우선순위의 프로세스가 실행되어야 할 때, 
기존의 프로세스 상태 또는 레지스터 값을 저장하고 CPU가 다음 프로세스를 수행하도록 교체하는 작업

## Stack과 Queue의 실사용 예
- Stack : 자바의 stack 메모리 영역, 지역 변수와 매개변수의 데이터 값이 저장되는 공간
- Queue : os의 스케줄러, 자원의 할당과 회수의 역할을 한다.

## Array와 ArrayList의 차이점
- Array는 크기가 고정적이고, 초기화 시 메모리에 할당되어 속도가 빠르다.
- ArrayList는 크기가 가변적이고, 데이터 추가 및 삭제 시 메모리를 재할당하기 때문에 속도가 느리다.

## 제네릭
- 데이터의 타입을 하나로 지정하지 않고, 사용할 때마다 범용적이고 포괄적으로 지정한다.
- 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있다.
