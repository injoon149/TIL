## 트리
- 두 지점의 연결 관계로 구성되어 있는데, 계층관계가 존재한다는 것이 특징이다.
- 노드 : 각 지점을 의미하고, 정점이라 부르기도 한다.
- 간선 : 두 노드를 연결하는 선을 의미하고, edge라고 부르기도 한다.
- 루트 노드 : 트리에서 맨 꼭대기를 의미한다.
- 부모, 자식 : 트리에서 연결된 두 노드의 관계를 의미하는데, 더 위쪽에 있는 노드를 부모 노드, 아래쪽에 있는 노드를
자식 노드라고 부른다.
- 차수 : 특정 노드를 기준으로, 자식의 수가 얼마나 되는지를 의미한다.
- 깊이 : 루트 노드와 얼마나 떨어져 있는지를 가리키는 말이다.
- 높이 : 트리에서 깊이가 가장 깊은 노드의 깊이 혹은 1을 더한 값을 의미한다.
- 리프 노드 : 자식을 갖고 있지 않은 노드를 의미한다.

## 이진 트리 개념 및 구현
- 자식의 수를 최대 2개로 제한한 트리이다.
- 루트 노드를 1번에 넣어주고, 왼쪽 자식을 2번, 오른쪽 자식을 3번에 넣어 준다. 그 후 왼쪽 자식의 자식부터 계속 배열에 등록한다
- 이렇게 되면 특정 노드의 위치가 i라고 한다면, 왼쪽 자식의 위치는 i*2, 오른쪽 자식의 위치는 i*2+1이다.
- 자식의 수가 제한되어 있어서, 구현하기 상대적으로 간편하다는 장점이 있다.

## 이진트리 탐색
- 재귀를 사용하여 탐색을 비교적 쉽게 구현할 수 있다.
- 전위 탐색은 부모, 왼쪽 자식, 오른쪽 자식 순으로 탐색한다
- 중위 탐색은 왼쪽 자식, 부모, 오른쪽 자식 순으로 탐색한다.
- 후위 탐색은 왼쪽 자식, 오른쪽 자식, 부모 순으로 탐색한다.

## 이진탐색트리
- 부모의 왼쪽 방향에 있는 노드들은 전부 부모보다 값이 작아야 하고, 부모의 우측 방향에 있는 노드들은 전부 부모보다
값이 커야만 한다.
- 이진 트리의 조건도 반드시 만족해야함을 잊지 말자.

## 이진 탐색 트리의 삭제
- 먼저 값 x를 찾는다.
1. 값을 찾았을 때 해당 노드의 왼쪽 노드가 비어있다면, node의 오른쪽 노드를 위로 올려준다.
2. 값을 찾았을 때 해당 노드의 오른쪽 노드가 비어있다면, node의 왼쪽 노드를 위로 올려준다.
3. 값을 찾았을 때 해당 노드의 왼쪽 오른쪽 노드가 전부 채워져 있다면, successor를 찾아야 한다. successor는 현재 노드를
기준으로 더 크면서 가장 작은 값을 갖는 노드를 뜻한다.

## 이진 탐색 트리의 시간 복잡도
- 최악의 경우 삽입/삭제/탐색 모두 O(N)이 된다.
- Red Black Tree나 AVL Tree같이 이진 탐색 트리를 특정 규칙에 따라 관리함으로써 O(logn)으로 관리할 수 있다.

## Heap
- max-heap, min-heap이 있으며, 원하는 heap 구조를 유지하는데 O(logn)만큼의 시간이 소요되고, 이는 주어진 수들 
중 최대 최소값을 O(1)에 구할 수 있게 해 준다.
- 모든 노드에 대해 부모 노드가 자신의 자식 노드가 갖는 값보다 같거나 큰 경우 : max-heap
- max-heap의 특징: 루트 노드에는 전체 숫자 중 최댓값이 항상 들어 있다.
- max-heap을 만드는 데에는 시간이 O(N)만큼, 특정 원소 하나를 삭제 삽입하는 데에는 O(logn)만큼, 최댓값 구하기는
O(1)만큼의 시간이 소요된다.
- max-heap에는 k번째 최댓값을 구할 수 없고, 가장 큰 값이 무엇인지만 알 수 있다.
- 원소의 추가, 최댓값의 삭제가 빈번하게 일어나는 상황에서 현재 남아있는 원소들 중 최댓값을 빠르게 얻고 싶은
경우에 heap 자료구조가 유용하다.

## heap 만들기
1. 숫자들을 순서대로 배열에 넣고, 순서대로 이진 트리로 만든다.
2. n / 2번째 원소부터 거꾸로 1번째 원소까지 순서대로 보면서 heapify라는 과정을 거친다.
3. heapify : 현재 노드를 기준으로 이 노드가 heap 특성에 맞을 때까지 계속 밑으로 내려주는 과정