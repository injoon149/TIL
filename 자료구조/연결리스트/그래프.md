## 그래프 용어
1. 모든 정점들에 대해 어느 두 정점을 잡아도 갈 수 있는 경로 존재 : connected graph
2. 그렇지 않은 그래프 : 비 연결 그래프
3. 연결된 정점을 전부 묶었을 때 만들어지는 그룹 : 연결 요소
4. 인접 행렬로 그래프 만들기
- v * v 크기의 2차원 배열을 만들어서 연결 관계를 표현한다. a에서 b로 가는 길이 있다면 배열의 값을 1로,
가는 길이 없다면 배열의 값을 0으로 지정한다.
- 특정 정점 i, j가 연결되어 있는지를 확인 : O(1)
- 특정 정점과 연결되어 있는 모든 정점을 확인 : O(V)
- 공간 복잡도 : O(V^2)
- 
5. 인접 리스트로 그래프 만들기
- v개의 연결 리스트를 만들고, 연결 리스트에 특정 정점과 인접해 있는 정점들의 정보를 담는다.
- 특정 정점 i, j가 연결되어 있는지를 확인 : O(min(degree(I), degree(J)))
- 특정 정점과 연결되어 있는 모든 정점을 확인 : O(degree(X))
- 공간 복잡도 : O(V+E)
- 
6. BFS
- 너비 우선 탐색 : 큐를 사용한다.
- 각각의 이웃들을 큐에 넣는다 : 시작 노드의 이웃 -> 그 다음 노드의 이웃 -> 그 다음 다음 노드의 이웃 순으로 방문
- 시간 복잡도 자체는 DFS와 동일하나, 실제로 코드를 짜게 되면 재귀함수의 오버헤드 때문에 DFS가 약간 느리다.
- BFS를 이용한 최단거리는, 가중치만 전부 동일하다면 확실하게 구할 수 있다.

7. 다익스트라 알고리즘
- 특정 시작점에서 다른 모든 정점으로 가는 최단거리를 각각 구해주는 알고리즘.
- 특정 지점까지 거리 = A까지 가는 거리 + A에서 특정 지점까지 소요되는 거리
- 거리 배열을 아주 큰 값(INF)으로 초기화하고, 출발지의 값만 0으로 설정한다. 우선순위 큐를 이용하여 최솟값을
골라주는 과정을 여러 번 반복하며 효과적으로 최솟값을 계속 찾는다.
- 음수 가중치가 있을 때의 최단거리는 다익스트라를 이용해서 구할 수 없다.

8. 다익스트라 알고리즘 - 시간 복잡도
- 한 시작점에서 다른 지점들까지의 최단 거리 : O(V^2)
- 우선순위 큐를 사용할 때: O(ElogV)
- 모든 쌍에 대한 최단 거리 : O(V^3)
- 우선순위 큐를 사용할 때:  O(VElogV)

9. Floyd - Warshall 알고리즘
- 모든 쌍에 대한 최단 거리를 구할 때 유용한 알고리즘이다.
- 1. v^2 크기의 배열 내에 있는 모든 값을 INF로 채워 준다.
- 2. 주어진 그래프에서 각 간선에 적혀 있는 숫자를 dist 배열에 적어 준다.
- 3. dist[i][j] > dist[i][1] + dist[1][j]를 만족하는 경우, 즉 어느 정점을 경유해서 가는게 더 좋은 경우 그 값을 갱신해 준다.
- 4. 이렇게 n번 노드까지 진행하게 되면 dist 배열에 각 쌍에 대한 최단 거리만 남게 된다.
- 시간 복잡도 : O(V^3)
- 정점의 수가 많지 않거나 모든 쌍에 대한 최단 거리를 구해야만 할 때 사용한다.

10. Kruskal 알고리즘
- 1. Spanning Tree : 최소한의 간선을 이용하여 그래프 내 모든 간선을 이어주는 것.
- 2. Minimum Spanning Tree(MST) : 가중치가 있을 때 최소한의 비용을 사용한 Spanning Tree
- 특정 원소가 어떤 집합에 속해 있는지 확인하고, 특정 집합을 합칠 일이 있다면 Union-Find 자료 구조를 사용하는 것이 좋다.
- uf 배열의 값은 그룹으로서의 의미가 아니라, 실제 노드가 현재 가리키고 있는 부모 노드의 번호가 된다.
- Kruskal 알고리즘 : 간선의 가중치가 작은 것부터 순서대로 보면서 해당 간선 양 끝에 있는 두 노드 x, y에 대해
find(x), find(y) 값을 비교하여 일치하지 않는 경우에만 간선을 선택해 주고, union(x, y)를 진행해주는
식으로 계속 진행한다.
- 이러한 과정을 모든 간선에 대해 진행하면, 그래프에서 노드의 수를 N이라 했을 때 최종적으로 선택된
간선의 수는 N-1개가 되며, 이 N-1개의 간선이 MST를 이룬다.
- 따라서 Union-Find를 활용하면, 정렬 한 번으로 kruskal 알고리즘을 구현할 수 있다.
- 간선을 정렬하는 시간복잡도 : O(ElogE)
- 각 간선에 대해 union-find : O(logn)
- 총 시간복잡도 : ElogE + ElogN = O(ElogE)가 된다.


