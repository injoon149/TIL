1. Masking : 개인 정보 보호를 위한 하나의 보안 과정
2. 마크업 : 우리가 보는 웹 페이지 화면
3. 하드코딩 : 데이터를 직접 코드 내부에 넣는 방식
4. - : 하이픈이라고 부름
5. 비즈니스 로직: 객체가 어떻게 동작하는지에 대한 과정
6. ^(캐럿), ~(틸트), \(백틱)
7. 네이티브 앱: 모바일 기기에 최적화된 앱, 안드로이드 및 ios 호환이 불가하여 각각 프로그램을 만들어야 한다.
8. 동적 쿼리 : 실행 시에 특정 조건이나 상황에 따라 쿼리 문장이 변경되어 실행되는 쿼리문. 컴파일 시에 sql 문장을 확정할 수 없는 경우에 사용한다.
9. MSA(MicroService Architecture)
  - 1개의 시스템을 독립적으로 배포 가능한 각각의 서비스로 분할한다. 각각의 서비스는 api를 통해 데이터를 주고받으며 1개의 큰 서비스를 구성한다.
10. sql - delete, truncate, drop의 차이
  - 1. Delete는 데이터는 지우지만, 테이블 용량은 줄어들지 않고 원하는 데이터만 골라서 지울 수 있다. 삭제 후 되돌릴 수 있음.
  - 2. Truncate는 전체 데이터를 한 번에 삭제하는 방식이다. 테이블은 삭제할 수 없고, 삭제 후 되돌릴 수 없음.
  - 3. Drop은 테이블 자체를 온전히 삭제하는 방식이다. 삭제 후 되돌릴 수 없음.
11. 동적 계획법(DP)
  - 주어진 문제를 풀기 위해, 문제를 여러 개의 하위 문제로 나누어 푸는 방법을 의미한다.
  - 답을 한 번만 계산하고, 그 결과를 재활용하는 memoization 기법으로 속도를 향상시킨다.
12. JWT 토큰
  - JWT는 JSON 포맷을 이용하는 claim 기반의 웹 토큰이며, 토큰 자체를 정보로 사용하는 self-contained 방식으로 정보를 안전하게 전달한다.
  - 헤더, 내용, 서명으로 구성되며 각 파트를 점으로 구분한다.
13. 멀티 프로세스와 멀티 쓰레드의 특징
  - 멀티 프로세스는 하나의 프로세스가 죽어도 다른 프로세스에 영향을 끼치지 않고 계속 실행된다는 장점이 있지만, 멀티 쓰레드보다 메모리와 cpu를 더 많이
    차지한다.
  - 멀티 쓰레드는 멀티 프로세스보다 메모리를 적게 차지하고, context switching이 빠르지만 하나의 쓰레드가 문제가 생기면 전체 쓰레드가 영향을 받는다.
14. 프로세스와 쓰레드의 차이
  - 프로세스는 실행 중인 프로그램을 말하며, 메모리 영역(코드, 데이터, 힙 등)을 다른 프로세스와 공유하지 않는다. 프로세스는 최소 1개의 메인 쓰레드
    를 가진다.
  - 쓰레드는 프로세스 내에서 스택을 따로 할당받고, 그 이외의 메모리 영역을 공유하기 때문에 다른 쓰레드의 실행 결과를 즉시 확인 가능하다.
15. 멀티 쓰레드 환경의 주의사항
  - 다수의 쓰레드가 공유 데이터에 동시에 접근하는 경우에 교착 상태가 일어나지 않도록 해야 한다.
16. Lombok 라이브러리
  - Lombok은 메소드를 컴파일하는 과정에 개입해서 추가적인 코드를 만들어 낸다.
  - 이를 annotation processing이라 하고, 자바 컴파일러가 컴파일 단계에서 애노테이션을 분석하고 처리하는 기법을 말한다.
17. Servlet : 자바를 사용해 웹을 만들기 위해 필요한 기술
18. @Transactional에서 readonly 속성을 사용하는 이유
  - 트랜잭션 안에서 수정/삭제 작업이 아닌 읽기 목적인 경우에 주로 사용하며, 영속성 컨텍스트에서 엔티티를 관리할 필요가 없어 readonly를 추가하는 것으로
    메모리 성능을 높일 수 있다.
19. DB Lock
  - 트랜잭션 처리의 순차성을 보장하기 위한 방법
  - 공유락: 트랜잭션이 읽기할 때 사용하는 락이며, 같은 공유락끼리는 동시에 접근 가능하다.
  - 배타 락: write Lock이라고도 부르고, 데이터를 변경할 때 사용하는 락이다. 트랜잭션이 완료될 때까지 유지되며, 접근허용x
20. having과 where의 차이
  - having은 집계 함수와 함께 사용하고, 그룹화 또는 집계가 발생한 후 필터링하는 데에 사용된다.
  - where는 그룹화 또는 집계가 발생하기 전에, 개별 행을 필터링하는 데에 사용된다.
21. join에서 on과 where의 차이
  - on이 where보다 먼저 실행되어, join을 하기 전에 필터링을 하고, join을 한 결과에서 where 조건절로 필터링이 이루어진다.
22. WAS와 WS의 차이
  - WAS : 비즈니스 로직을 넣을 수 있음. Tomcat, PHP 등
  - WS : 비즈니스 로직 x, nginx, apache 등
23. 애노테이션
  - @RequestBody : 클라이언트가 전송하는 JSON 형태의 HTTP Body 내용을 Message Converter를 통해 Java 객체로 변환시켜준다. 
    변수들의 생성자, getter, setter가 없어도 정상적으로 할당된다.
  - @RequestParam : 1개의 HTTP 요청 파라미터를 받기 위해 사용한다. 반드시 필요한 변수가 아니라면 required의 값을 false로 설정한다.
  - @ModelAttribute : HTTP Body의 내용과 HTTP 파라미터의 값들을 생성자, getter, setter를 통해 주입하기 위해 사용한다.
24. Spring의 스코프, 프로토타입 빈
  - 프로토타입 빈은 싱글톤 빈과는 달리 컨테이너에게 빈을 요청할 때마다 매번 새로운 객체를 생성하여 반환해 준다.
  - 빈의 scope 설정 : @Scope 어노테이션
  - 프로토타입 빈으로 설정: @Scope("prototype")
25. @Transactional
  - @Transactional을 메소드 또는 클래스에 명시하면, AOP를 통해 Target이 상속하고 있는 인터페이스 또는 Target 객체를 상속한 프록시 객체가
    생성되며, 프록시 객체의 메소드를 호출하면 Target 메소드 전후로 트랜잭션을 처리한다.
26. Reflection
  - 구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들에 접근할 수 있게 해 주는 자바 api
27. 제네릭
  - 데이터의 타입을 하나로 지정하지 않고, 사용할 때마다 범용적으로 지정한다.
  - 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있다.
28. 옵티마이저
  - SQL을 가장 빠르고 효율적으로 수행할 최적의 처리 경로를 생성해 주는 DBMS 내부의 핵심 엔진이다.
29. DB 튜닝
  - DB 구조나 DB 자체, 운영체제 등을 조정하여 DB 시스템의 전체적인 성능을 개선하는 작업.
  - 튜닝은 DB 설계 튜닝 -> DBMS 튜닝 -> SQL 튜닝 단계로 진행한다.
30. DB 클러스터 / 리플리케이션
  - 클러스터링 : 여러 개의 DB를 수평적인 구조로 구축. 동기 방식이며, DB 간의 데이터 동기화 가능, 가용성이 높고, 로드 밸런싱이 가능하지만,
                비용이 많이 든다.
  - 리플리케이션 : 여러 개의 DB를 권한에 따라 수직적인 구조로 구축하는 방식. 비동기 방식이며, 지연 시간이 짧다. master DB가 다운되면 복구가
                  까다롭다는 단점이 있다.
31. 동기/비동기
  - 동기는 서버에 데이터를 요청하고, 데이터가 응답할 때까지 이후 태스크들은 block된다.
  - 비동기는 서버에 데이터를 요청한 이후 서버로부터 데이터가 응답할 떄까지 기다리지 않고 즉시 다음 태스크를 계속해서 수행한다.
32. 자바 11과 자바 17의 차이
  - 1. 자바 17에서는 람다식과 익명 클래스에서도 var를 사용할 수 있다.
  - 2. GC(가비지 컬렉션) 기능 향상. 암호화와 보안 기능 업데이트
  - 3. 성능 개선












