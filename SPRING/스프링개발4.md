## 다양한 의존관계 주입 방법
1. 생성자 주입
- 생성자를 통해서 의존 관계를 주입받는 방법이다. 생성자 호출시점에 딱 1번만 호출되는 것이 보장되고, 불변, 필수 의존
관계에 사용된다.
- 생성자가 딱 1개만 있으면 @Autowired를 생략해도 자동 주입된다.

2. 수정자 주입(setter 주입)
- 수정자 메서드를 통해서 의존 관계 주입. 선택, 변경 가능성이 있는 의존 관계에 사용된다.
- @Autowired의 기본 동작은 주입할 대상이 없으면 오류가 발생해서, 그럴 때 동작하게 하려면
@Autowired(required = false)로 지정한다.

3. 필드 주입
- 외부에서 변경이 불가능해서 테스트하기 힘들고, 스프링 설정 코드에서만 특별한 용도로 사용

## 옵션 처리
- 주입할 스프링 빈이 없어도 동작해야 할 때가 있다.
- 자동 주입 대상을 옵션으로 처리하는 방법
1. @Autowired(required = false) : 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출이 안됨
2. org.spring.framework.lang.@Nullable : 자동 주입할 대상이 없으면 null이 입력된다.
3. Optional<> : 자동 주입할 대상이 없으면 Optional.empty가 입력된다.

## 생성자 주입을 선택해야 하는 이유
1. 대부분의 의존관계 주입은 불변한데, 생성자 주입은 객체를 생성할 때 딱 1번만 호출되므로
이후에 호출되는 일이 없다. 
2. 생성자 주입을 사용하면 주입 데이터를 실수로 누락했을 때 컴파일 오류가 발생하므로, IDE에서
바로 어떤 값을 필수로 주입해야 하는지 알 수 있다.
3. 필드에 final 키워드를 사용할 수 있어서, 생성자에서 혹시라도 값이 설정되지 않는 오류를
컴파일 시점에 막아 준다.

## 롬복과 최신 트렌드
- 롬복 라이브러리가 제공하는 `@RequiredArgsConstructor` 기능을 사용하면, final이 붙은 필드를
모아서 생성자를 자동으로 만들어 준다.
- 자바의 애노테이션 프로그램 시작 필요 : settings에 들어가서 annotation processing을 활성화해 준다.

## 조회 대상 빈이 2개 이상일 때
1. @Autowired 필드 명 매칭
    - @Autowired는 타입 매칭을 시도하고, 이 때 여러 빈이 있으면 필드 이름, 파라미터 이름으로 빈 이름을 추가 매칭한다.
2. @Qualifier -> @Qualifier끼리 매칭, 그 후 빈 이름 매칭
    - 추가 구분자 사용
3. @Primary 사용
    - 우선순위를 정한다. @Autowired 시에 여러 빈이 매칭되면 @Primary가 우선권을 가진다.

## 조회한 빈이 모두 필요할 때
- Map<String, DiscountPolicy> : map의 키에 스프링 빈의 이름을 넣어주고, 그 값으로 DiscountPolicy 타입으로
조회한 모든 스프링 빈을 담아 준다.
- List<DiscountPolicy> : DiscountPolicy 타입으로 조회한 모든 스프링 빈을 담아 준다.
- 해당하는 타입의 스프링 빈이 없으면, 빈 컬렉션이나 Map을 주입한다.
- 따라서, map이나 list를 활용하여 조회한 빈이 모두 필요할 때 사용할 수 있다.

## 빈 생명주기 콜백
- 데이터베이스 커넥션 풀이나, 네트워크 소켓처럼 애플리케이션 시작 시점에 필요한 연결을 미리 해 두고, 애플리케이션
종료 시점에 연결을 모두 종료하는 작업을 진행할 때, 객체의 초기화와 종료 작업 사용
- 애플리케이션 시작 시점에 호출되는 함수, 종료 전에 호출되는 함수를 정의한다.

## 스프링 빈의 이벤트 라이프사이클
- 스프링 컨테이너 생성->스프링 빈 생성->의존관계 주입->초기화 콜백->사용->소멸 전 콜백->스프링 종료
- 초기화 콜백: 빈이 생성되고, 빈의 의존관계 주입이 완료된 후 호출
- 소멸전 콜백: 빈이 소멸되기 직전에 호출.
- `객체의 생성과 초기화를 명확하게 분리하자.`

## 빈 생명주기 콜백 지원하는 3가지 방법
1. 인터페이스(InitializingBean, DisposableBean) : 거의 사용하지 않음
2. 설정 정보에 초기화 메서드, 종료 메서드 지정 : 스프링 이외에 외부 라이브러리에 사용
3. @PostConstruct, @PreDestroy 애노테이션 : 제일 많이 사용

## 인터페이스
- InitializingBean은 afterPropertiesSet() 메서드로 초기화를 지원한다.
- DisposableBean은 destroy() 메서드로 소멸을 지원한다.
- NetworkClient 클래스에서 InitializingBean, DisposableBean을 각각 implement하고, 각 메서드를 override해서 정의한다.
- 단점: 스프링 전용 인터페이스에 의존하게 되고, 초기화 및 소멸 메서드의 이름을 변경할 수 없으며, 
외부 라이브러리에 적용할 수 없다.

## 빈 등록 초기화, 소멸 메서드 지정
- 설정 정보에 `@Bean(initMethod = "init", destroyMethod = "close")`처럼 초기화, 소멸 메서드를 지정할 수 있다.
- 메서드 이름을 자유롭게 줄 수 있고, 스프링 코드에 의존하지 않으며 외부 라이브러리에도 적용 가능.
- 직접 스프링 빈으로 등록하면, destroyMethod의 추론 기능에 의해, 종료 메서드를 따로 적어주지 않아도,
스프링이 직접 close, shutdown 라는 이름의 메서드를 자동으로 호출해 준다.
- 추론 기능을 사용하기 싫으면 `destroyMethod= ""` 처럼 빈 공백을 지정하면 된다.

## 애노테이션 활용
- 초기화 콜백 함수에 @PostConstruct, 종료전 콜백 함수에 @Predestroy 애노테이션을 달아 준다.
- 최신 스프링에서 가장 권장하는 방법이며, 애노테이션 하나만 붙이면 된다.
- 단점: 외부 라이브러리에 적용을 못 한다. 외부 라이브러리를 초기화, 종료해야 하면 @Bean의 기능을 이용하자.







