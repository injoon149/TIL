## 네이티브 SQL
- JPA가 지원하는, SQL을 직접 사용할 수 있는 기능.
- 특정 데이터베이스에 의존하는 기능을 사용해야 할 때, SQL은 지원하지만 JPQL이 지원하지 않는 기능을 사용해야 할 때
- 단점: 특정 데이터베이스에 의존하는 SQL을 작성해야 하고, 데이터베이스를 변경하면 네이티브 SQL도 수정해야 한다.

## 페이징
- 사용자에게 데이터를 제공할 때 전체 데이터 중의 일부분을 보여주는 방식
- 페이징 API
1. SetFirstResult(int startPosition) : 조회 시작 위치, 0부터 시작한다.
2. SetMaxResults(int maxResult) : 조회할 데이터 수

## API 개발 고급 정리
1. 엔티티 조회
- 엔티티를 조회해서 그대로 반환 : V1 -> 엔티티 스펙이 변하면 API 스펙도 변하게 되어 사용X
- 엔티티 조회 후 DTO로 변환 : V2
- 페치 조인으로 쿼리 수 최적화 : V3 (성능 최적화)
- 콜렉션 페이징과 한계 돌파 : V3.1
- - 컬렉션은 페치 조인 시 페이징이 불가능하기 때문에 등장하였다. ToOne 관계는 페치 조인으로 쿼리 수를 최적화한다.
컬렉션은 페치 조인 대신에 지연 로딩을 유지하고, @BatchSize로 최적화한다.

2, DTO 직접 조회
- JPA에서 DTO를 직접 조회 : V4
- 컬렉션 조회 최적화 : 일대다 관계인 컬렉션은 IN 절을 활용해서 메모리에 미리 조회해서 최적화 : V5
- 플랫 데이터 최적화 : Join 결과를 그대로 조회 후 애플리케이션에서 원하는 모양으로 직접 변환 : V6

3. 권장 순서
- 엔티티 조회 방식으로 우선 접근 : 페치 조인으로 쿼리 수를 최적화하고, 컬렉션을 최적화한다.
- 엔티티 조회 방식으로 해결이 안되면 DTO 조회 방식 사용.
- DTO 조회 방식으로 해결이 안되면 NativeSQL 또는 스프링 JDBCTemplate 사용.

4. cache할 때 : 엔티티를 절대 직접 cache하지 말고 DTO로 변환해서 해야 한다
- Cache의 예시 : Redis

## OSIV과 성능 최적화
- OSIV : Open Session In View
- OSIV이 켜져 있을 때, 최초부터 끝까지 영속성 컨텍스트가 생존한다.
- OSIV 전략: 최초 데이터베이스 커넥션 시작 지점부터 API 응답이 끝날 때까지 영속성 컨텍스트와 데이터베이스 커넥션을
유지한다. -> View Template나 API 컨트롤러에서 지연 로딩이 가능하게 한다.
- 단점: 오랜 시간 동안 데이터베이스 커넥션 리소스를 사용하기 때문에, 실시간 트래픽이 중요한 애플리케이션에서는
커넥션이 모자랄 수 있다. 예를 들어, 컨트롤러에서 외부 API를 호출하면 외부 API 대기 시간만큼 커넥션 리소스를 반환 불가하다.
- OSIV이 꺼져 있을 때, 서비스나 레포지토리 클래스(트랜잭션 범위) 부터 영속 상태로서, 수정이 가능하다.

## OSIV을 끄면?
- 트랜잭션을 종료할 때 영속성 컨텍스트를 닫고, 데이터베이스 커넥션도 반환한다. => 커넥션 리소스 낭비X
- @Transactional 이 붙은 메소드 끝나면 DB 커넥션도 반환한다.
- 모든 지연 로딩을 트랜잭션 안에서 처리해야 한다. => 지연 로딩 코드를 다 트랜잭션 안으로 넣어야 한다.
- 성능 최적화를 위해서는 OSIV을 끄는 게 좋다.
- OSIV을 켜면, 지연 로딩을 아무데나 가능하게 함으로써 코드 복잡성이 줄어들고, 끄면 성능이 올라간다.
- 고객 서비스의 실시간 API 같이 성능이 중요하고 정보량이 많으면 OSIV을 끈다.

## 스프링 데이터 JPA
- JPA를 사용할 때 반복되는 코드를 자동화해준다.
- 스프링 데이터 JPA는 JPARepository라는 인터페이스를 제공하는데, 여기에 기본적인 CRUD 기능이 모두 제공된다.

## QueryDSL
- 조건에 따라서 실행되는 쿼리가 달라지는 "동적 쿼리"를 사용할 때 유용하다.
- build.gradle에 QueryDSL을 추가하고, gradle로 가서 task-other-compileQueyDSL 한번 해주어야 함.
- QMember 등 있는 파일은 gitignore로 빼서, 빌드 타임에 생성될 수 있도록 한다.

## OAuth
- 등장 배경: 구글, 페이스북 등 SNS의 ID, 비밀번호 등을 직접 제공받아 우리의 서비스에 저장하기에는 정보 유출의 위험성이 높다.
- 다양한 SNS 플랫폼의 특정 사용자 데이터에 접근하기 위해 제3자 클라이언트가 사용자의 접근 권한을 위임받을 수 있는 표준 프로토콜.
- 우리의 서비스가 우리 서비스를 이용하는 유저의 타사 플랫폼 정보에 접근하기 위해 권한을 타사 플랫폼으로부터 위임받는다.

## OAuth 용어
1. Resource Owner
- 우리의 서비스를 이용하면서, 구글, 페이스북 등의 플랫폼에서 리소스를 소유하고 있는 사용자이다.
2. Authorization Server
- 리소스 소유자를 인증하고, 클라이언트에게 액세스 토큰을 발급해주는 서버이다.
3. Resource Server : 구글, 페이스북 등과 같이 리소스를 가지고 있는 서버
4. Redirect URL
- OAuth 2.0 서비스는 인증이 성공한 사용자를 사전에 등록한 Redirect URL로만 리디렉션시킨다. 승인되지 않은 URL로 리다이렉션할
경우 정보 탈취 위험 때문 => 보안을 위해 Redirect URL은 https만 허용되지만, localhost는 예외적으로 http를 허용한다.
5. Client ID, Client Secret
- 액세스 토큰을 획득하는 데 사용된다.
- Client ID는 공개되어도 상관 x, client secret은 공개되면 안됨.

## 설정 파일 관리
- 깃허브에서 private repository 생성해서 서브모듈로 관리하는 게 좋다.
- 로컬, 배포 때 쓸 DB가 다르면 application-dev.yml, application-main.yml로 따로 관리하는 게 좋다.

## ToString 애노테이션
- exclude 속성을 사용해 특정 필드를 결과에서 제거, of 속성으로 필드 추가 가능하다.

## @NoArgsConstructor(AccessLevel.Protected)
- 엔티티 클래스에서 JPA 스펙상 protected로 기본 생성자를 열어 두어야 한다.

## 빌더 클래스
- setter 대신 사용할 수 있는 클래스 패턴이다.
- 복잡한 객체의 생성 과정과 표현 방법을 분리하여 다양한 구성의 인스턴스를 만드는 생성 패턴이다.
- 생성자 파라미터를 사용하는 것보다 가독성이 좋고, 어떤 값을 먼저 설정하든 상관이 없으며, 객체의 불변성을 보장한다.

## 공통 인터페이스
- 스프링 데이터 JPA가 애플리케이션 로딩 시점에 구현 클래스를 대신 생성해 준다.
- 공통 메서드
- save(s) : 새로운 엔티티는 저장하고 이미 있는 엔티티는 병합한다.
- delete(T) : 엔티티 하나 삭제
- findById(id) : 엔티티 하나 조회
- getOne(id) : 엔티티를 프록시로 조회
- findAll(...) : 모든 엔티티 조회

## 쿼리 메소드 기능
- 메소드 이름으로 쿼리 생성
- 메소드 이름으로 JPA NamedQuery 호출
- @Query 애노테이션을 사용해서 리포지토리 인터페이스에 쿼리 직접 정의

## 스프링 데이터 JPA가 제공하는 쿼리 메소드 기능
- 조회 : find~By, read~By, Query~By, Get~By
- Count: Count~By
- Exists : Exists~By
- 삭제 : delete~By, remove~By
- Distinct : findDistinct, findMemberDistinctBy
- Limit : findFirst3, findFirst, findTop, findTop3
- 이 기능은 엔티티의 필드명이 변경되면 인터페이스에 정의한 메소드 이름도 변경해야 한다. => 애플리케이션 로딩 시점에 오류를 
인지할 수 있게 한다.

## JPA NamedQuery
- @NamedQuery 어노테이션으로 Named 쿼리 정의

## @Query : 리포지토리 메소드에 쿼리 직접 정의
- 메소드에 JPQL 쿼리 작성 -> 메소드 이름으로 쿼리 생성 기능은 파라미터가 증가하면 이름이 지저분해져서, @Query 기능을 주로
사용하게 된다.
- DTO로 직접 조회할 수도 있다.