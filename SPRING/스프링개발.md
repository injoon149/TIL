## 네이티브 SQL
- JPA가 지원하는, SQL을 직접 사용할 수 있는 기능.
- 특정 데이터베이스에 의존하는 기능을 사용해야 할 때, SQL은 지원하지만 JPQL이 지원하지 않는 기능을 사용해야 할 때
- 단점: 특정 데이터베이스에 의존하는 SQL을 작성해야 하고, 데이터베이스를 변경하면 네이티브 SQL도 수정해야 한다.

## 페이징
- 사용자에게 데이터를 제공할 때 전체 데이터 중의 일부분을 보여주는 방식
- 페이징 API
1. SetFirstResult(int startPosition) : 조회 시작 위치, 0부터 시작한다.
2. SetMaxResults(int maxResult) : 조회할 데이터 수

## API 개발 고급 정리
1. 엔티티 조회
- 엔티티를 조회해서 그대로 반환 : V1 -> 엔티티 스펙이 변하면 API 스펙도 변하게 되어 사용X
- 엔티티 조회 후 DTO로 변환 : V2
- 페치 조인으로 쿼리 수 최적화 : V3 (성능 최적화)
- 콜렉션 페이징과 한계 돌파 : V3.1
- - 컬렉션은 페치 조인 시 페이징이 불가능하기 때문에 등장하였다. ToOne 관계는 페치 조인으로 쿼리 수를 최적화한다.
컬렉션은 페치 조인 대신에 지연 로딩을 유지하고, @BatchSize로 최적화한다.

2, DTO 직접 조회
- JPA에서 DTO를 직접 조회 : V4
- 컬렉션 조회 최적화 : 일대다 관계인 컬렉션은 IN 절을 활용해서 메모리에 미리 조회해서 최적화 : V5
- 플랫 데이터 최적화 : Join 결과를 그대로 조회 후 애플리케이션에서 원하는 모양으로 직접 변환 : V6

3. 권장 순서
- 엔티티 조회 방식으로 우선 접근 : 페치 조인으로 쿼리 수를 최적화하고, 컬렉션을 최적화한다.
- 엔티티 조회 방식으로 해결이 안되면 DTO 조회 방식 사용.
- DTO 조회 방식으로 해결이 안되면 NativeSQL 또는 스프링 JDBCTemplate 사용.

4. cache할 때 : 엔티티를 절대 직접 cache하지 말고 DTO로 변환해서 해야 한다
- Cache의 예시 : Redis

## OSIV과 성능 최적화
- OSIV : Open Session In View
- OSIV이 켜져 있을 때, 최초부터 끝까지 영속성 컨텍스트가 생존한다.
- OSIV 전략: 최초 데이터베이스 커넥션 시작 지점부터 API 응답이 끝날 때까지 영속성 컨텍스트와 데이터베이스 커넥션을
유지한다. -> View Template나 API 컨트롤러에서 지연 로딩이 가능하게 한다.
- 단점: 오랜 시간 동안 데이터베이스 커넥션 리소스를 사용하기 때문에, 실시간 트래픽이 중요한 애플리케이션에서는
커넥션이 모자랄 수 있다. 예를 들어, 컨트롤러에서 외부 API를 호출하면 외부 API 대기 시간만큼 커넥션 리소스를 반환 불가하다.
- OSIV이 꺼져 있을 때, 서비스나 레포지토리 클래스(트랜잭션 범위) 부터 영속 상태로서, 수정이 가능하다.

## OSIV을 끄면?
- 트랜잭션을 종료할 때 영속성 컨텍스트를 닫고, 데이터베이스 커넥션도 반환한다. => 커넥션 리소스 낭비X
- @Transactional 이 붙은 메소드 끝나면 DB 커넥션도 반환한다.
- 모든 지연 로딩을 트랜잭션 안에서 처리해야 한다. => 지연 로딩 코드를 다 트랜잭션 안으로 넣어야 한다.
- 성능 최적화를 위해서는 OSIV을 끄는 게 좋다.
- OSIV을 켜면, 지연 로딩을 아무데나 가능하게 함으로써 코드 복잡성이 줄어들고, 끄면 성능이 올라간다.
- 고객 서비스의 실시간 API 같이 성능이 중요하고 정보량이 많으면 OSIV을 끈다.